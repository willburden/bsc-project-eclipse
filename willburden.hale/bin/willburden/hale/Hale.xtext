grammar willburden.hale.Hale hidden(WS, ML_COMMENT, SL_COMMENT)

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate hale "http://www.hale.willburden/Hale"

/*************************************************************
 * Top-level
 ************************************************************/

Hale:
	{Hale}
	mainBlock=Block
;

Block:
	{Block}
	(statements+=Statement | ';')*
;

Statement:
	BracedBlock |
	Function |
	If |
	While |
	((
		Print |
		LetBinding |
		Assignment |
		Break |
		Return |
		Throw |
		Expression
	) ';')
;

BracedBlock returns Block:
	'{' Block '}'
;

/*************************************************************
 * Literals
 ************************************************************/

Literal:
	VoidLiteral |
	BooleanLiteral |
	NumberLiteral |
	StringLiteral
;

VoidLiteral:
	{VoidLiteral} 'void'
;

BooleanLiteral:
	value=BOOLEAN
;

NumberLiteral:
	value=DOUBLE
;

StringLiteral:
	value=STRING
;

/*************************************************************
 * Types
 ************************************************************/

TypeAnnotation returns Type:
	':' Type
;

Type returns Type:
	FunctionType
;

FunctionType returns Type:
	(
		{FunctionType}
		'Function' '('
			(paramTypes+=Type (',' paramTypes+=Type)* ','?)?
		')'
		(returnType=TypeAnnotation)?
	) |
	EitherType
;

EitherType returns Type:
	PrimaryType ({EitherType.left=current} '?' right=PrimaryType)*
;

PrimaryType returns Type:
	PrimitiveType |
	'(' Type ')'
;

PrimitiveType returns Type:
	{PrimitiveType}
	type=PRIMITIVE_TYPE
;

/*************************************************************
 * Bindings
 ************************************************************/

Binding:
	name=ID
;

LetBinding:
	'let' (mutable?='mut')? binding=Binding
	(type=TypeAnnotation)? '=' expression=Expression
;

BindingReference:
	binding=[Binding]
;

Assignment:
	binding=[Binding] '=' expression=Expression
;

/*************************************************************
 * Input/Output
 ************************************************************/

Input:
	{Input} 'input'
;

Print:
	'print' expression=Expression
;

/*************************************************************
 * Control flow
 ************************************************************/

If:
	'if' (IfLet | IfConditions)
;

IfLet:
	'let' (mutable?='mut')? binding=Binding (type=TypeAnnotation)?
	'=' expression=Expression
		ifBlock=BracedBlock
	('else' elseLet=ElseLet)?
;

ElseLet:
	('let' (mutable?='mut')? binding=Binding (type=TypeAnnotation)?)?
		elseBlock=BracedBlock
;

IfConditions:
	conditions+=Expression ifBlocks+=BracedBlock
	('elseif' conditions+=Expression ifBlocks+=BracedBlock)*
	('else' elseBlock=BracedBlock)?
;

While:
	'while' condition=Expression block=BracedBlock
;

Break:
	{Break} 'break'
;

/*************************************************************
 * Functions
 ************************************************************/

Function:
	'function' binding=Binding '('
		(parameters+=Parameter (',' parameters+=Parameter)* ','?)?
	')'
	(returnType=TypeAnnotation)?
	body=BracedBlock
;

Parameter:
	{Parameter}
	(mutable?='mut')? binding=Binding type=TypeAnnotation
;

Return:
	{Return}
	'return' (expression=Expression)?
;

Throw:
	{Throw}
	'throw' (expression=Expression)?
;

/*************************************************************
 * Expressions
 ************************************************************/

// Start with expressions of lowest precedence, since we
// are generating a syntax tree.
Expression returns Expression:
	Expression10
;

Expression10 returns Expression:
	Expression9 ({Concatenation.left=current} '.' right=Expression9)*
;

Expression9 returns Expression:
	Expression8 (
		({LogicalAnd.left=current} 'and' right=Expression8) |
		({LogicalOr.left=current} 'or' right=Expression8)
	)*
;

Expression8 returns Expression:
	Expression7 (
		({Equality.left=current} '==' right=Expression7) |
		({Inequality.left=current} '!=' right=Expression7)
	)*
;

Expression7 returns Expression:
	Expression6 (
		({LessThanOrEqual.left=current} '<=' right=Expression6) |
		({LessThan.left=current} '<' right=Expression6) |
		({GreaterThanOrEqual.left=current} '>=' right=Expression6) |
		({GreaterThan.left=current} '>' right=Expression6)
	)*
;

Expression6 returns Expression:
	Expression5 (
		({Addition.left=current} '+' right=Expression5) |
		({Subtraction.left=current} '-' right=Expression5)
	)*
;

Expression5 returns Expression:
	Expression4 (
		({Multiplication.left=current} '*' right=Expression4) |
		({Division.left=current} '/' right=Expression4) |
		({Remainder.left=current} '%' right=Expression4)		
	)*
;

Expression4 returns Expression:
	Expression3 ({Exponentiation.left=current} '**' right=Expression3)*
;

Expression3 returns Expression:
	Expression2 ({Conversion.left=current} 'as' right=Type)*
;

Expression2 returns Expression:
	({UnaryNegation} '-' inner=Expression2) |
	({LogicalNot} 'not' inner=Expression2) |
	Expression1
;

Expression1 returns Expression:
	Expression0 ({Application.expression=current} '('
		(arguments+=Expression (',' arguments+=Expression)* ','?)?
	')')*
;

Expression0 returns Expression:
	Literal |
	Input |
	BindingReference |
	'(' Expression ')'
;

/*************************************************************
 * Terminals
 ************************************************************/

terminal PRIMITIVE_TYPE: 'Void' | 'Boolean' | 'Number' | 'String';
terminal BOOLEAN returns ecore::EBoolean: 'true' | 'false';

terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;

terminal DOUBLE returns ecore::EDouble: ('0'..'9')+ ('.' ('0'..'9')+)?;
terminal STRING:
			'"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
			"'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
		;

terminal ML_COMMENT : '/*' -> '*/';
terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;

terminal WS         : (' '|'\t'|'\r'|'\n')+;
