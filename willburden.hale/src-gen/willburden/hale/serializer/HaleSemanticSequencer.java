/*
 * generated by Xtext 2.34.0
 */
package willburden.hale.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import willburden.hale.hale.Addition;
import willburden.hale.hale.Assignment;
import willburden.hale.hale.Binding;
import willburden.hale.hale.BindingReference;
import willburden.hale.hale.Division;
import willburden.hale.hale.Hale;
import willburden.hale.hale.HalePackage;
import willburden.hale.hale.IntLiteral;
import willburden.hale.hale.Multiplication;
import willburden.hale.hale.Print;
import willburden.hale.hale.StringLiteral;
import willburden.hale.hale.Subtraction;
import willburden.hale.services.HaleGrammarAccess;

@SuppressWarnings("all")
public class HaleSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private HaleGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == HalePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case HalePackage.ADDITION:
				sequence_Expression(context, (Addition) semanticObject); 
				return; 
			case HalePackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case HalePackage.BINDING:
				sequence_Binding(context, (Binding) semanticObject); 
				return; 
			case HalePackage.BINDING_REFERENCE:
				sequence_BindingReference(context, (BindingReference) semanticObject); 
				return; 
			case HalePackage.DIVISION:
				sequence_Expression(context, (Division) semanticObject); 
				return; 
			case HalePackage.HALE:
				sequence_Hale(context, (Hale) semanticObject); 
				return; 
			case HalePackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case HalePackage.MULTIPLICATION:
				sequence_Expression(context, (Multiplication) semanticObject); 
				return; 
			case HalePackage.PRINT:
				sequence_Print(context, (Print) semanticObject); 
				return; 
			case HalePackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case HalePackage.SUBTRACTION:
				sequence_Expression(context, (Subtraction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Assignment
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (binding=[Binding|ID] value=Expression)
	 * </pre>
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.ASSIGNMENT__BINDING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.ASSIGNMENT__BINDING));
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.ASSIGNMENT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.ASSIGNMENT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getBindingBindingIDTerminalRuleCall_0_0_1(), semanticObject.eGet(HalePackage.Literals.ASSIGNMENT__BINDING, false));
		feeder.accept(grammarAccess.getAssignmentAccess().getValueExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns BindingReference
	 *     BindingReference returns BindingReference
	 *     Expression returns BindingReference
	 *     Expression.Multiplication_1_0_0 returns BindingReference
	 *     Expression.Division_1_1_0 returns BindingReference
	 *     Expression.Subtraction_1_2_0 returns BindingReference
	 *     Expression.Addition_1_3_0 returns BindingReference
	 *     TerminalExpression returns BindingReference
	 *
	 * Constraint:
	 *     binding=[Binding|ID]
	 * </pre>
	 */
	protected void sequence_BindingReference(ISerializationContext context, BindingReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.BINDING_REFERENCE__BINDING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.BINDING_REFERENCE__BINDING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBindingReferenceAccess().getBindingBindingIDTerminalRuleCall_0_1(), semanticObject.eGet(HalePackage.Literals.BINDING_REFERENCE__BINDING, false));
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Binding
	 *     Binding returns Binding
	 *
	 * Constraint:
	 *     (mutable?='mut'? name=ID value=Expression)
	 * </pre>
	 */
	protected void sequence_Binding(ISerializationContext context, Binding semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Addition
	 *     Expression returns Addition
	 *     Expression.Multiplication_1_0_0 returns Addition
	 *     Expression.Division_1_1_0 returns Addition
	 *     Expression.Subtraction_1_2_0 returns Addition
	 *     Expression.Addition_1_3_0 returns Addition
	 *     TerminalExpression returns Addition
	 *
	 * Constraint:
	 *     (left=Expression_Addition_1_3_0 right=TerminalExpression)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Addition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.ADDITION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.ADDITION__LEFT));
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.ADDITION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.ADDITION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getAdditionLeftAction_1_3_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTerminalExpressionParserRuleCall_1_3_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Division
	 *     Expression returns Division
	 *     Expression.Multiplication_1_0_0 returns Division
	 *     Expression.Division_1_1_0 returns Division
	 *     Expression.Subtraction_1_2_0 returns Division
	 *     Expression.Addition_1_3_0 returns Division
	 *     TerminalExpression returns Division
	 *
	 * Constraint:
	 *     (left=Expression_Division_1_1_0 right=TerminalExpression)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Division semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.DIVISION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.DIVISION__LEFT));
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.DIVISION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.DIVISION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getDivisionLeftAction_1_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTerminalExpressionParserRuleCall_1_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Multiplication
	 *     Expression returns Multiplication
	 *     Expression.Multiplication_1_0_0 returns Multiplication
	 *     Expression.Division_1_1_0 returns Multiplication
	 *     Expression.Subtraction_1_2_0 returns Multiplication
	 *     Expression.Addition_1_3_0 returns Multiplication
	 *     TerminalExpression returns Multiplication
	 *
	 * Constraint:
	 *     (left=Expression_Multiplication_1_0_0 right=TerminalExpression)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Multiplication semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.MULTIPLICATION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.MULTIPLICATION__LEFT));
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.MULTIPLICATION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.MULTIPLICATION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getMultiplicationLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTerminalExpressionParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Subtraction
	 *     Expression returns Subtraction
	 *     Expression.Multiplication_1_0_0 returns Subtraction
	 *     Expression.Division_1_1_0 returns Subtraction
	 *     Expression.Subtraction_1_2_0 returns Subtraction
	 *     Expression.Addition_1_3_0 returns Subtraction
	 *     TerminalExpression returns Subtraction
	 *
	 * Constraint:
	 *     (left=Expression_Subtraction_1_2_0 right=TerminalExpression)
	 * </pre>
	 */
	protected void sequence_Expression(ISerializationContext context, Subtraction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.SUBTRACTION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.SUBTRACTION__LEFT));
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.SUBTRACTION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.SUBTRACTION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getSubtractionLeftAction_1_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRightTerminalExpressionParserRuleCall_1_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Hale returns Hale
	 *
	 * Constraint:
	 *     statements+=Statement*
	 * </pre>
	 */
	protected void sequence_Hale(ISerializationContext context, Hale semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns IntLiteral
	 *     Expression returns IntLiteral
	 *     Expression.Multiplication_1_0_0 returns IntLiteral
	 *     Expression.Division_1_1_0 returns IntLiteral
	 *     Expression.Subtraction_1_2_0 returns IntLiteral
	 *     Expression.Addition_1_3_0 returns IntLiteral
	 *     TerminalExpression returns IntLiteral
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=INT
	 * </pre>
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns Print
	 *     Print returns Print
	 *
	 * Constraint:
	 *     value=Expression
	 * </pre>
	 */
	protected void sequence_Print(ISerializationContext context, Print semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.PRINT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.PRINT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrintAccess().getValueExpressionParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Statement returns StringLiteral
	 *     Expression returns StringLiteral
	 *     Expression.Multiplication_1_0_0 returns StringLiteral
	 *     Expression.Division_1_1_0 returns StringLiteral
	 *     Expression.Subtraction_1_2_0 returns StringLiteral
	 *     Expression.Addition_1_3_0 returns StringLiteral
	 *     TerminalExpression returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 * </pre>
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, HalePackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, HalePackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
